# -*- coding: utf-8 -*-
"""scrabble

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1THfhELb5kuLSYJXFgIMTnCZWzOZ4DwRw
"""

!git push origin master

"""# Build Dictionary"""

# Builds the dictionary data structure 
file = open("../enable1.txt", "r") 
words = file.read().split()
dic = {}
for word in words:
  summ = 0
  for letter in word:
    summ += 10**(25 - (ord(letter) - 97))
  if summ in dic:
     dic[summ].append(word)
  else:
    dic[summ] = [word]

"""# Anagram Solver"""

#Returns the words containing the same combination
#of letters
def getWords(word):
  summ = 0
  for letter in word:
      summ += 10**(25 - (ord(letter) - 97))
  if summ in dic:
    return dic[summ]
  else: 
    return []

#returns all possible words with all possible letter combinations
def allWords(word,allLetters = False):
  words = set()
  for num in range(1,2**len(word)):
    newWord = ""
    code = ("0" * len(word)) + "{0:b}".format(num)
    for i in range(0,len(word)):
      if code[len(code) - i - 1] == "1":
        newWord += word[i]
    oWords = getWords(newWord)
    if len(oWords) > 0:
      for i in range(0,len(oWords)):
        words.add(oWords[i])
  words = list(words)
  for w in words: 
    print(w)

print("What are your letters: ", end="")
allWords(input())

"""# Creat image scanning and manipulation functions"""

startPixel = (43,815)
blocksPerRow = 15
blocksPerColumn = 15
w, h = 66, 66
inbetweenWalls = 8
boundBoxWidth = 55
boundBoxHeight = 44
xDistStartToLb = -29
yDistStartToLb = - 45
translator = set()
wordCodes = []

def starScan(point, samples = 7):
  value = 0
  for i in range(1,samples + 1):
    if(isLetter(pix[point[0] - 2,point[1] - 1 -(boundBoxHeight / samples) * i])):
      value += 10**(i * 4)
    if isLetter(pix[point[0] + xDistStartToLb + (boundBoxWidth / samples) * i,point[1] - 23]):
      value += 10**(i * 4 + 1)
    if isLetter(pix[getLeftBound(point)[0] + (boundBoxWidth/ samples) * i,
        getLeftBound(point)[1] + (boundBoxHeight / samples) * i]):
      value += 10**(i * 4 + 2)
    if isLetter(pix[getLeftBound(point)[0] + (boundBoxWidth/ samples) * i,
        getLeftBound(point)[1] + boundBoxHeight - (boundBoxHeight / samples) * i]):
      value += 10**(i * 4 + 3)
  translator.add(value)
  wordCodes.append(value)
  
  if value ==  100011101111010100010000:
    color = (0,255,0)
  else:
    color = (255,0,255)
  #change the points colors for visualization purposes
  for i in range(1,samples + 1):
    pix[point[0] - 2,point[1] - 1 -(boundBoxHeight / samples) * i] = color
    pix[point[0] + xDistStartToLb + (boundBoxWidth / samples) * i,point[1] - 23] = color
    pix[getLeftBound(point)[0] + (boundBoxWidth/ samples) * i,
        getLeftBound(point)[1] + (boundBoxHeight / samples) * i] = color
    pix[getLeftBound(point)[0] + (boundBoxWidth/ samples) * i,
        getLeftBound(point)[1] + boundBoxHeight - (boundBoxHeight / samples) * i] = color

def blockScan(point):
  lb = getLeftBound(point)
  code = 0
  for c in range(boundBoxWidth):
    for r in range(boundBoxHeight):
      if (isLetter(pix[c,r])):
        code +=  10**(c + (r + 56))
  return code
    
def getLeftBound(point):
  return (point[0]-29,point[1] - 45)

def drawBox(startPoint, endPoint = False, color = (255,0,0),w=20,h=20):
  if endPoint is not False:
    w = endPoint[0] - startPoint[0]
    h = endPoint[1] - startPoint[1]
  for i in range(0,w + 1):
    pix[startPoint[0] + i,startPoint[1]] = color
    pix[startPoint[0] + i,startPoint[1] + h] = color
  for i in range(0,h + 1):
    pix[startPoint[0],startPoint[1] + i] = color
    pix[startPoint[0] + w,startPoint[1] + i] = color
    

def isOrange(rgb):
  if rgb[0] >=  200 and rgb[0] <= 255:
    if rgb[1] >= 114 and rgb[1] <= 220:
      if rgb[2] >= 0 and rgb[2] <= 110:
        return True
  return False

def isLetter(rgb):
  if rgb[0] >= 230 and rgb[1] >= 230 and rgb[2] >= 230:
    return True
  if rgb[0] >=  49 and rgb[0] <= 100:
    if rgb[1] >= 16 and rgb[1] <= 50:
      if rgb[2] >= 0 and rgb[2] <= 30:
        return True
  return False

"""# Scan Image and Mark-up picture"""

from google.colab import files

from PIL import Image
wordCodes = []

im = Image.open('../scrabblewords.JPG') # Can be many different formats.
pix = im.load()
im.show()
allPixels = []
print(im.size)  # Get the width and height of the image for iterating over
for r in range(0,15):
  for c in range(0,15): 
    if(isOrange(pix[43 + ((66 + 8) * c),815 + ((66 + 8) * r) ])):  # Get the RGBA Value of the a pixel of an image
      pix[43 + ((66 + 8) * c),815 + ((66 + 8) * r)] = (255,0,0)# Set the RGBA Value of the image (tuple)
      lb = getLeftBound((43 + ((66 + 8) * c),815 + ((66 + 8) * r)))
      starScan((43 + ((66 + 8) * c),815 + ((66 + 8) * r)))
      #USE BLOCK SCAN
      #allPixels.append(blockScan((43 + ((66 + 8) * c),815 + ((66 + 8) * r))))
      #END BLOCK SCAN
      drawBox(lb,(lb[0] + 55,lb[1] + 44 ))
im.save('markedScrabble.png')  # Save the modified pixels as .png
files.download('markedScrabble.png')

"""# Set Up Letter Translations"""

translationDic = {}
letterOrder = ["m","b","a","m","a","w","n","p","y","l","o","r","i",
              "c","t","i","r","e","u","t","tw","t","h","u","j",
               "a","s","a","n","t","i","a","g","e","o","p",
               "r","d","o","z","a","r","e",'l',"i","e","d","e",
               "i","d","e","n","f","o","d","i","t","e","l","u",
               "g","s","h","t","r","a","c","k","s","v","i","n",
               "o","v","o","e","a","u","y","o","f","e","d","n",
               "s","l","i","t","e"
              ]

for c in range(len(wordCodes)):
  name = letterOrder[c]
  if wordCodes[c] in translationDic:
    translationDic[wordCodes[c]].append(name)
  else:
    translationDic[wordCodes[c]] = [name]
print(len(translationDic.keys()))

translationDic

"""# Kmap Solver


*   For any digit that aren't consistent with the that digit in the the other values of that letter letter
"""

